# Loads up trajectories by reading a set of CSV files.
# 
# Makes lots of assumptions about:
# * file names - <video id>.csv
# * CSV trajectory file structure - generated by YetAnotherTracker
# * metadata location - sampleIt application
# * etc

library(trajr)
library(JUtils)
source("constants.R")
source("mimic-types.R")
source(SAMPLEIT_API)

CSV_STRUCT <- list(x = "x", y = "y", time = "Time")


# Picks all tracks longer than the specified number of points and duration
.pickLongTracks <- function(points, minLength, minDuration) {
  tids <- unique(points$TrackId)
  msr <- sapply(tids,
                function(tid) {
                  trj <- TrajFromCoords(points[points$TrackId == tid, ],
                                        CSV_STRUCT["x"], CSV_STRUCT["y"], CSV_STRUCT["time"])
                  TrajLength(trj) > minLength && TrajDuration(trj) >= minDuration
                })
  tids[which(msr)]
}

# Fills in missing frames by copying the position from the last available frame.
# This function assumes a constant frame rate
.addMissingFrames <- function(points) {
  gaps <- diff(points$Frame) - 1
  pos <- which(gaps > 0)
  
  # We want a row for every frame id within the existing range
  allFrameIds <- min(points$Frame):max(points$Frame)
  # Copy from either the original frame if it exists, otherwise the last row with a lower frame
  srcIdxs <- match(allFrameIds, points$Frame)
  fixedFrames <- which(is.na(srcIdxs))
  for (i in fixedFrames)
    srcIdxs[i] <- srcIdxs[i - 1]
  r <- points[srcIdxs, ]
  # Fix up frame numbers
  r$Frame <- allFrameIds
  # Fix up times assuming a strictly linear relationship between frame ID and time
  r$Time[fixedFrames] <- r$Frame[fixedFrames] / FpsFromPoints(points)
  
  r
}

# Reads a set of points from a CSV file. The file may contain multiple tracks
# due to noise in the video conversion process, or because there are multiple
# animals being tracked. 
# 
# Typically, the longest track is the one we are interested in.
# 
# @param minLength Only trajectories with at least this many points are returned.
# @param minDuration Only trajectories with at least this duration are returned.
# @param trackIds Vector of track IDs to retain, or, if negative, to discard.
# 
# Value - list of data frames of points, each with attributes:
# "CSV": name of CSV file containing points;
# "videoID": ID of the video within the sampleIt database;
# "trackID": ID of the track within the video.
# 
.readPoints <- function(file, minLength, minDuration, trackIds, overrideSpecimen) {
  points <- read.csv(file, comment.char = '#')
  # Convert left-handed coord-system to right (or is it the other way around?)
  points$y <- max(points$y, na.rm = TRUE) - points$y
  
  # Save the number of frames in the file in case the track doesn't extend until the end
  maxFrame <- max(points$Frame)
  
  tids <- .pickLongTracks(points, minLength, minDuration)
  
  # Allow tracks to be explicitly selected or rejected by track ID
  if (!missing(trackIds)) {
    trackIds <- na.omit(trackIds)
    retain <- trackIds[trackIds >= 0]
    discard <- -trackIds[trackIds < 0]
    if (length(retain) > 0)
      tids <- tids[tids %in% retain]
    if (length(discard) > 0)
      tids <- tids[!tids %in% discard]
  }
  
  lapply(tids, function(tid) {
    pts <- .addMissingFrames(points[points$TrackId == tid, ])
    attr(pts, "CSV") <- basename(file)
    attr(pts, "videoID") <- tools::file_path_sans_ext(basename(file))
    attr(pts, "trackID") <- tid
    attr(pts, "specimenID") <- overrideSpecimen
    pts
  })
}

# Combines multiple tracks produced by Physlets tracker into a single track.
# This might be useful because tracker becomes unusably slow for long tracks
.joinTrackerTracks <- function(dir, basename) {
  files <- list.files(dir, pattern = paste0(basename, ".*\\.csv"), full.names = TRUE)
  l <- lapply(files, .readTrackerPts)
  # Update time of each successive track to start after the end of the previous track
  frameTime <- l[[1]]$t[2] - l[[1]]$t[1]
  lastTime <- -frameTime
  for (i in seq_along(l)) {
    # Start this track after the end of the previous track
    l[[i]]$t <- l[[i]]$t + lastTime + frameTime
    # Save last time of the track
    lastTime <- tail(l[[i]]$t, 1)
  }
  do.call(rbind, l)
}

# Reads a trajectory as a set of (time, x, y) points exported from Physlets tracker
.readTrackerPts <- function(filename) {
  points <- read.csv(filename, header = TRUE, stringsAsFactors = FALSE, skip = 1)
  points[, c("x", "y", "t")]
}

# Builds a list of trajectories and associated meta data.
# Metadata are obtained by querying my sampleIt database.
#
# Returns a list with 2 elements:
#  trjs - a list of trajectories
#  metaInfo - information about each trajectory
buildTrajectories <- function(videoListFile) {
  videoList <- read.csv(videoListFile, stringsAsFactors = FALSE)
  videoList <- videoList[videoList$Usable != "No",]
  # Work out if any files should exist but don't
  videoList$file <- file.path(VIDEO_DIR, videoList$Dir, paste0(videoList$Video, ".csv"))
  exist <- file.exists(videoList$file)
  nMissing <- sum(!exist)
  if (nMissing > 0)
    cat(sprintf("Skipping missing CSV file%s: %s\n", ifelse(nMissing == 1, "", "s"), JToSentence(unique(videoList$file[!exist]))))
  videoList <- videoList[exist, ]
  
  # Process videos in random order to try to get a reasonable estimate of time to completion
  set.seed(1)
  trjs <- lapply(sample(nrow(videoList)), function(idx) {
    vid <- videoList[idx, ]
    # The .readPoints function reads a CSV file and returns coordinates for all
    # trajectories with length at least minLength, and with duration at least
    # 2.1 sec, and optionally selecting or rejecting specific tracks as
    # specified by trackIds
    #cat(sprintf("Loading %s, min length %g, smoothing %d\n", vid$file, vid$Minimum.track.length..m., vid$Smoothing))
    TrajsBuild(vid$file,
               csvStruct = CSV_STRUCT,
               csvReadFn = .readPoints,
               minLength = vid$Minimum.track.length..m.,
               minDuration = 2.1,
               trackIds = vid$Track.ID,
               overrideSpecimen = vid$Override.specimen,
               #smoothN = vid$Smoothing,
               smoothN = NA, # characteriseTrajectory performs smoothing
               smoothP = NA,
               timeUnits = "s",
               spatialUnits = "m")
  })
  
  # Flatten list of lists
  #trjs <- do.call(c, trjs)
  trjs <- unlist(trjs, recursive = FALSE)
  
  # Give each trajectory a unique ID
  for (id in seq_along(trjs)) {
    attr(trjs[[id]], "trjID") <- id
  }
  
  # Build meta data
  # Get info about photos from database
  photoInfo <- SIQueryPhotos(sprintf("id=[%s]", paste(unique(videoList$Video), collapse = ',')))
  ### NOTE complication is that some videos contain trajectories for multiple specimens.
  # Create "fake" video information for these videos with imageableid set to the override specimen id
  overrides <- videoList[!is.na(videoList$Override.specimen), c("Video", "Override.specimen")]
  oVideos <- photoInfo[photoInfo$id %in% overrides$Video, ]
  oVideos[, "imageableid"] <- overrides[match(oVideos$id, overrides$Video), "Override.specimen"]
  photoInfo <- rbind(photoInfo, oVideos)

  # Get info about specimens for photos
  specimenInfo <- SIQuerySpecimensForPhotos(photoInfo)

  # Combine specimen and photo info. 
  # photoInfo$imageableid is a reference to the specimen id from the video
  # specimenInfo$id is the specimen id
  info <- merge(photoInfo, specimenInfo, by.x = "imageableid", by.y = "id")
  
  # Match up photo info to trajectories. Each video may produce multiple trajectories
  x <- function(t) {
    # This is sort of a 2-column match function
    tv <- attr(t, "videoID")
    os <- attr(t, "specimenID")
    which(tv == info$id & (is.na(os) | os == info$imageableid))[1]
  }
  metaInfo <- info[sapply(trjs, x), ]
  metaInfo$mimicType <- mimicTypeFromMetaInfo(metaInfo)
  
  # Combine trajectories with meta data
  list(trjs = trjs, metaInfo = metaInfo)
}

# Returns a subset of trajectory info, with metadata indices matching up with trajectory indices
SubsetTrjInfo <- function(trjInfo, idxs) {
  list(trjs = trjInfo$trjs[idxs], metaInfo = trjInfo$metaInfo[idxs, ], stats = trjInfo$stats[idxs, ])
}


# Reads and returns previously cached trajectories and stats.
LoadCachedTrajectories <- function() {

  if (!file.exists(CACHED_TRJS))
    return(NULL)
  
  # Read cached trajectories
  readRDS(CACHED_TRJS)
}